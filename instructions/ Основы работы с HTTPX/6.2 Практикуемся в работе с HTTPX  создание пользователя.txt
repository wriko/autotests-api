В данном уроке мы подробнее поработаем с библиотекой HTTPX, чтобы основательно закрепить свои знания и навыки работы с этим инструментом. Мы будем работать с эндпоинтами /api/v1/users, которые отвечают за управление пользователями. Операции включают создание, удаление, редактирование и получение данных пользователя. Все эти операции называются CRUD.

Что такое CRUD?
CRUD — это аббревиатура, обозначающая четыре основные операции, которые могут быть выполнены с данными в большинстве баз данных и приложений. Каждая буква в аббревиатуре означает:

Create (создание) — добавление нового объекта (например, создание нового пользователя).
Read (чтение) — извлечение данных о существующем объекте (например, получение информации о пользователе).
Update (обновление) — изменение существующего объекта (например, обновление данных пользователя).
Delete (удаление) — удаление объекта (например, удаление пользователя).
Эти операции лежат в основе работы большинства современных веб-приложений, и понимание их очень важно при тестировании API.

========================================================================================================================
Работа с пользователями

Работа с пользователями выбрана не случайно, так как после того, как мы освоили работу с аутентификацией, следующим важным этапом является работа с пользователями. В большинстве систем пользователи — это одна из базовых и основных сущностей. Все остальные данные часто зависят от пользователя.

Возьмем, к примеру, банковскую систему: там есть карты, счета, операции, выписки, лимиты и прочее, но всего этого не может существовать, если нет сущности пользователя (клиента банка). Поэтому работа с пользователями является важнейшим этапом, особенно когда мы начинаем писать автотесты для коммерческих проектов.

Начнем с создания пользователя. Для того чтобы создать пользователя, необходимо выполнить POST запрос на эндпоинт /api/v1/users. В теле запроса нужно передать следующий JSON:

    {
      "email": "user@example.com",
      "password": "string",
      "lastName": "string",
      "firstName": "string",
      "middleName": "string"
    }
Важно! Этот эндпоинт не требует авторизации.


---------------------------------
1. Создание файла httpx_create_user.py
---------------------------------
В корне проекта autotests-api создаем файл httpx_create_user.py.

.
└── autotests-api/
    └── httpx_create_user.py

---------------------------------
2. Добавляем скрипт создания пользователя
---------------------------------
В файл httpx_create_user.py добавим следующий код:

    import httpx

    payload = {
        "email": "user@example.com",
        "password": "string",
        "lastName": "string",
        "firstName": "string",
        "middleName": "string"
    }
    response = httpx.post("http://localhost:8000/api/v1/users", json=payload)

    print(response.status_code)
    print(response.json())

Важно! Этот код выглядит рабочим, и он действительно может работать, но есть одно но: если пользователь с email user@example.com уже существует, при повторной попытке создать пользователя с таким же email мы получим ошибку:

    {
      "detail": "User with email user@example.com already exists"
    }

Нас такой расклад не устраивает, поэтому в данной ситуации самым правильным выходом будет создавать каждый раз пользователя с уникальным email. Давайте разберемся, как это можно сделать.

---------------------------------
3. Создаем генератор случайного email
---------------------------------
Чтобы сделать email уникальным, нам нужно написать функцию, которая будет рандомизировать локальную часть email (до символа @), например, test.1740687022.054204@example.com. Доменную часть, то есть @example.com, можно оставить статичной.

Создадим папку tools, а в ней файл fakers.py.

.
├── autotests-api/
│   └── httpx_create_user.py
└── tools/
    └── fakers.py
В файл fakers.py добавим следующий код:

    import time


    def get_random_email() -> str:
        return f"test.{time.time()}@example.com"

Эта функция будет генерировать уникальный email в формате test.1740687022.054204@example.com. Она использует функцию time.time(), которая в каждый момент времени возвращает уникальный таймстамп. Это гарантирует, что наш email будет всегда уникален в любой момент времени.

Что такое таймстамп?
Таймстамп (timestamp) — это числовое значение, которое представляет собой количество секунд или миллисекунд, прошедших с определенного времени (обычно с 1 января 1970 года, известного как "эпоха Unix"). Использование таймстампов позволяет гарантировать уникальность значений, так как каждое новое значение будет представлять собой временную метку, которая всегда увеличивается.

---------------------------------
4. Дорабатываем скрипт
---------------------------------
Теперь, когда у нас есть функция для генерации уникальных email, давайте применим её в нашем скрипте.

Обновленный скрипт httpx_create_user.py будет выглядеть так:

    import httpx
    from tools.fakers import get_random_email  # Импортируем функцию для генерации случайного email

    payload = {
        "email": get_random_email(),  # Используем функцию для генерации случайного email
        "password": "string",
        "lastName": "string",
        "firstName": "string",
        "middleName": "string"
    }
    response = httpx.post("http://localhost:8000/api/v1/users", json=payload)

    print(response.status_code)
    print(response.json())

---------------------------------
5. Запускаем скрипт
---------------------------------
Теперь запускаем скрипт с помощью команды:

    python -m httpx_create_user

В результате получим следующий вывод в консоль:

    200
    {'user': {'id': '9bb2edb9-7201-4b4a-a50c-218b9b3873a0', 'email': 'test.1740687666.45349@example.com', 'lastName': 'string', 'firstName': 'string', 'middleName': 'string'}}


Как мы видим пользователь был успешно создан и этот именно тот результат, который мы хотели получить.

Важно! В идеальных автотестах желательно, чтобы все данные рандомизировались и были более приближенными к реальным пользовательским данным. Например, логично, что у пользователя не будет firstName = "string". В будущем мы проработаем этот нюанс, когда будем знакомиться с библиотекой Faker.