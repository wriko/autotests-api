Подготовка к запуску автотестов на CI: GitHub Actions
Ссылки:

GitHub Actions Marketplace - https://github.com/marketplace?type=actions
GitHub Action для установки python - https://github.com/actions/setup-python
GitHub Action для извлечения кода репозитория - https://github.com/actions/checkout
GitHub Action для загрузки артефактов - https://github.com/actions/upload-artifact
GitHub Action для скачивания артефактов -https://github.com/actions/download-artifact
GitHub Actioin для генерации Allure отчета с сохранением истории - https://github.com/simple-elf/allure-report-action
GitHubActions для публикации на GitHub Pages - https://github.com/peaceiris/actions-gh-pages


В этом уроке мы разберем, как запустить автотесты на CI, используя GitHub Actions.

Важно! В этом уроке мы будем работать с различными GitHub Actions, необходимыми для автоматизации процессов в CI/CD.
Версии используемых Actions регулярно обновляются, поэтому крайне важно проверять актуальные версии в официальных репозиториях перед их использованием.

Обратите внимание, что версии, указанные в текстовых и видео-материалах курса, могут отличаться от актуальных на момент вашего прохождения урока.
Поэтому рекомендую открыть официальные репозитории используемых Actions, ознакомиться с последними версиями и проверить документацию.
Ссылки на официальные репозитории всех использованных в курсе Actions приведены выше.

-------------------------------
1. Создаем файл workflow: .github/workflows/tests.yml
-------------------------------
Для начала нужно создать файл .github/workflows/tests.yml, в котором будут описаны все инструкции для запуска автотестов.

.
└── autotests-api/
    └── .github/
        └── workflows/
            └── tests.yml

-------------------------------
2. Описываем шаги workflow
-------------------------------
Откроем файл .github/workflows/tests.yml и добавим в него инструкции, которые позволят GitHub Actions понять, как запускать наши автотесты.

Важно! Как вы помните, для того чтобы запускать автотесты локально, мы запускали тестовый сервер, доступный по адресу localhost:8000.
Соответственно, в CI/CD-процессе нам также необходимо настроить и запустить этот сервер, чтобы тесты могли выполняться и взаимодействовать с сервером.
Без работающего сервера тесты не смогут корректно работать. Напомню, что установку и настройку локального сервера мы проходили в уроке "Установка и настройка локального сервера".

    # Имя вашего workflow, которое будет отображаться в интерфейсе GitHub Actions
    name: API tests

    # Указываем, когда будет запускаться данный workflow
    on:
      push:
        branches:
          - main  # Запускать workflow, когда будет сделан коммит в ветку main
      pull_request:
        branches:
          - main  # Запускать workflow, когда будет сделан pull request в ветку main

    # Определяем все шаги, которые должны быть выполнены в рамках работы с тестами
    jobs:
      run-tests:
        runs-on: ubuntu-latest  # Указываем, что тесты будут запускаться на последней версии Ubuntu

        steps:
          # 1. Шаг, который будет клонировать ваш репозиторий на машину GitHub Actions
          - name: Check out repository
            uses: actions/checkout@v4  # Используем GitHub Action для клонирования репозитория

          # 2. Шаг для установки Python на виртуальной машине
          - name: Set up Python
            uses: actions/setup-python@v5  # Используем GitHub Action для установки Python
            with:
              python-version: '3.11'  # Устанавливаем версию Python 3.11 (можно заменить на другую версию)

          # 3. Шаг для клонирования репозитория с тестовым сервером в рабочую среду
          - name: Clone test server repository
            run: git clone https://github.com/Nikita-Filonov/qa-automation-engineer-api-course.git

          # 4. Шаг для установки зависимостей для тестового сервера
          - name: Install test server dependencies
            run: pip install -r qa-automation-engineer-api-course/requirements.txt

          # 5. Шаг для запуска тестового сервера с необходимыми переменными окружения
          - name: Start a test server
            env:
              APP_HOST: "http://localhost:8000"  # Устанавливаем адрес хоста сервера
              DATABASE_URL: "sqlite+aiosqlite:///./local.db" # Устанавливаем URL локальной базы данных
              JWT_ALGORITHM: "HS256" # Алгоритм для JWT токенов
              JWT_SECRET_KEY: "qa-automation-engineer-api-course-secret-key" # Секретный ключ для JWT
              JWT_ACCESS_TOKEN_EXPIRE: 1800 # Время жизни access token (в секундах)
              JWT_REFRESH_TOKEN_EXPIRE: 5184000 # Время жизни refresh token (в секундах)
            run: uvicorn main:app --host 0.0.0.0 --port 8000 --app-dir ./qa-automation-engineer-api-course & # Запускаем сервер с указанными переменными окружения

          # 6. Шаг для установки всех зависимостей проекта
          - name: Install dependencies
            run: |
              python -m pip install --upgrade pip  # Обновляем pip до последней версии
              pip install -r requirements.txt  # Устанавливаем зависимости, указанные в requirements.txt

          # 7. Шаг для запуска тестов с использованием pytest и генерации отчётов Allure
          - name: Run API tests with pytest and generate Allure results
            run: |
              pytest -m regression --alluredir=allure-results --numprocesses 2  # Запускаем тесты, отмеченные как "regression", генерируем результаты для Allure

          # 8. Шаг для получения истории отчётов Allure, если она существует
          - name: Get Allure history
            uses: actions/checkout@v4  # Опять клонируем репозиторий, чтобы получить историю отчётов
            if: always()  # Всегда выполняем, независимо от успеха или неудачи предыдущих шагов
            continue-on-error: true  # Если здесь возникнет ошибка, workflow всё равно продолжит выполнение
            with:
              ref: gh-pages  # Указываем ветку gh-pages для получения отчётов
              path: gh-pages  # Указываем путь для сохранения отчётов

          # 9. Шаг для генерации и отображения отчёта Allure
          - name: Generates Allure Report with history
            uses: simple-elf/allure-report-action@v1.12  # Используем готовое решение из GitHub Marketplace для генерации Allure отчёта
            if: always()  # Этот шаг тоже всегда выполняется
            with:
              allure_results: allure-results  # Указываем каталог с результатами тестов
              allure_history: allure-history  # Указываем каталог для истории отчётов Allure

          # 10. Шаг для деплоя отчёта Allure на GitHub Pages, чтобы его можно было просматривать в браузере
          - name: Deploy report to Github Pages
            if: always()  # Выполняется всегда, независимо от успеха других шагов
            uses: peaceiris/actions-gh-pages@v4  # Используем GitHub Action для публикации отчёта на GitHub Pages
            with:
              github_token: ${{ secrets.GITHUB_TOKEN }}  # Токен для аутентификации на GitHub
              publish_branch: gh-pages  # Указываем, что отчёт будет опубликован в ветке gh-pages
              publish_dir: allure-history  # Указываем папку, которая будет опубликована на GitHub Pages



Теперь давайте подробно разберем, что происзодит в данном файле

.................
1. Имя Workflow
.................
    name: API tests

Что происходит:
 - Этот параметр указывает имя для workflow в GitHub Actions. В данном случае, оно называется "API tests", и это имя будет отображаться в интерфейсе GitHub Actions, чтобы легко было найти и понять, что этот workflow связан с тестированием интерфейса.

.................
2. Триггеры для запуска Workflow
.................
    on:
      push:
        branches:
          - main  # Запускать на коммитах в main ветку
      pull_request:
        branches:
          - main  # Запускать на pull request'ах к main ветке

Что происходит:
Здесь задаются триггеры, которые запускают данный workflow:
 - push: Workflow будет запускаться каждый раз, когда кто-то сделает коммит в ветку main вашего репозитория.
 - pull_request: Workflow будет также запускаться, когда кто-то создаст pull request, нацеленный на ветку main.
Этот параметр позволяет настроить автоматический запуск тестов каждый раз, когда происходят изменения в главной ветке репозитория.

.................
3. Объявление Jobs
.................
    jobs:
      run-tests:
        runs-on: ubuntu-latest

Что происходит:
Здесь начинается определение jobs (работ), которые будут выполнены в рамках workflow. В данном случае мы создаём одну задачу — test.
 - runs-on: ubuntu-latest — Указывает, что задача будет выполняться на виртуальной машине с последней версией Ubuntu, предоставленной GitHub Actions. Это значит, что все шаги в этой задаче будут запускаться в среде Ubuntu, что гарантирует одинаковые условия для выполнения тестов.

.................
4. Шаг 1: Клонирование репозитория
.................
    - name: Check out repository
      uses: actions/checkout@v4  # Используем GitHub Action для клонирования репозитория

Что происходит:
На первом шаге используется стандартный GitHub Action actions/checkout@v3, который клонирует репозиторий на виртуальную машину, где будет выполняться тестирование. Это необходимо для того, чтобы GitHub Actions имел доступ к вашему коду и файлам проекта.

.................
5. Шаг 2: Настройка Python
.................
    - name: Set up Python
      uses: actions/setup-python@v5  # Используем GitHub Action для установки Python
      with:
        python-version: '3.12'  # Устанавливаем версию Python 3.11

Что происходит:
Этот шаг устанавливает Python на виртуальной машине:
 - Мы используем GitHub Action actions/setup-python@v4 для установки Python.
 - Указываем, что хотим установить Python версии 3.11. Это означает, что на виртуальной машине будет работать именно эта версия Python, а не какая-либо другая.
Этот шаг важен для того, чтобы окружение для тестов было настроено правильно и совместимо с вашими зависимостями (если они требуют определённой версии Python).

.................
6. Шаг 3: Клонирование репозитория с тестовым сервером
.................
    - name: Clone test server repository
      run: git clone https://github.com/Nikita-Filonov/qa-automation-engineer-api-course.git

Что происходит:
На этом шаге происходит клонирование репозитория с тестовым сервером, который будет использоваться для тестирования.
Мы используем команду git clone, чтобы скачать проект с тестовым сервером на виртуальную машину.
Это необходимо для того, чтобы подготовить сервер и его файлы для дальнейшей работы, включая установку зависимостей и запуск тестов.

.................
7. Шаг 4: Установка зависимостей для тестового сервера
.................
    - name: Install test server dependencies
      run: pip install -r qa-automation-engineer-api-course/requirements.txt

Что происходит:
Этот шаг отвечает за установку зависимостей, необходимых для работы тестового сервера. В файле requirements.txt указаны все библиотеки и пакеты, которые требуются для правильной работы тестового сервера (например, FastAPI, SQLAlchemy и другие). Мы используем команду pip install -r для установки всех этих зависимостей. Это важно, чтобы сервер работал с необходимыми библиотеками и был готов к запуску и тестированию.

.................
8. Шаг 5: Запуск тестового сервера с необходимыми переменными окружения
.................
    - name: Start a test server
      env:
        APP_HOST: "http://localhost:8000"  # Устанавливаем адрес хоста сервера
        DATABASE_URL: "sqlite+aiosqlite:///./local.db" # Устанавливаем URL локальной базы данных
        JWT_ALGORITHM: "HS256" # Алгоритм для JWT токенов
        JWT_SECRET_KEY: "qa-automation-engineer-api-course-secret-key" # Секретный ключ для JWT
        JWT_ACCESS_TOKEN_EXPIRE: 1800 # Время жизни access token (в секундах)
        JWT_REFRESH_TOKEN_EXPIRE: 5184000 # Время жизни refresh token (в секундах)
      run: uvicorn main:app --host 0.0.0.0 --port 8000 --app-dir ./qa-automation-engineer-api-course & # Запускаем сервер с указанными переменными окружения

Что происходит:
Этот шаг запускает тестовый сервер, используя утилиту uvicorn для запуска FastAPI приложения. Мы указываем необходимые переменные окружения, такие как адрес хоста сервера, URL базы данных и параметры для JWT токенов (секретный ключ, алгоритм, время жизни токенов). Запуск сервера происходит с флагом --app-dir, который указывает путь к директории с приложением. Сервер запускается в фоновом режиме, что позволяет продолжать выполнение следующих шагов в процессе CI/CD.

.................
9. Шаг 6: Установка зависимостей
.................
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip  # Обновляем pip до последней версии
        pip install -r requirements.txt  # Устанавливаем зависимости из requirements.txt

Что происходит:
Здесь выполняются следующие действия:
 - Сначала обновляется pip (менеджер пакетов Python) до последней версии.
 - Затем с помощью команды pip install -r requirements.txt устанавливаются все зависимости, которые указаны в файле requirements.txt вашего проекта. Этот файл обычно содержит все библиотеки, которые нужны для работы с вашим проектом, в том числе для запуска тестов.

.................
10. Шаг 7: Запуск тестов с pytest и генерация отчётов Allure
.................
    - name: Run API tests with pytest and generate Allure results
      run: |
        pytest -m regression --alluredir=allure-results --numprocesses 2  # Запускаем тесты и генерируем результаты для Allure

Что происходит:
Этот шаг запускает pytest — фреймворк для тестирования Python. Он будет искать тесты, помеченные маркером regression и запускать их. Результаты тестов будут сохраняться в папку allure-results в формате, совместимом с Allure.
Параметр --numprocesses 2 означает, что тесты будут выполняться параллельно в два потока, что ускоряет выполнение тестов.

.................
11. Шаг 8: Получение истории Allure отчётов
.................
    - name: Get Allure history
      uses: actions/checkout@v4  # Опять клонируем репозиторий для получения истории отчётов
      if: always()  # Всегда выполняем этот шаг
      continue-on-error: true  # Если будет ошибка, продолжим выполнение
      with:
        ref: gh-pages  # Указываем ветку gh-pages для получения истории
        path: gh-pages  # Указываем путь, куда сохранить данные

Что происходит:
На этом шаге мы снова клонируем репозиторий, но на этот раз из ветки gh-pages — ветки, где будет храниться история отчётов Allure. Эти отчёты необходимы для сравнения новых результатов с предыдущими.
 - if: always() гарантирует, что этот шаг выполнится всегда, независимо от того, были ли успешными предыдущие шаги.
 - continue-on-error: true означает, что даже если этот шаг завершится с ошибкой, workflow продолжит выполняться.

.................
12. Шаг 9: Генерация отчёта Allure
.................
    - name: Generates Allure Report with history
      uses: simple-elf/allure-report-action@v1.12  # Используем готовое решение для генерации Allure отчёта
      if: always()  # Выполняем всегда
      with:
        allure_results: allure-results  # Указываем каталог с результатами тестов
        allure_history: allure-history  # Указываем каталог для истории отчётов

Что происходит:
Здесь используется готовое решение для генерации отчёта Allure. Это действие из GitHub Marketplace автоматически создает визуальный отчёт о выполнении тестов, который можно просматривать в браузере.
 - allure_results — указывает на папку, где хранятся результаты тестов.
 - allure_history — указывает на папку для истории предыдущих отчётов, чтобы можно было сравнивать новые и старые результаты тестов.

.................
13. Шаг 10: Деплой отчёта на GitHub Pages
.................
    - name: Deploy report to Github Pages
      if: always()  # Выполняем всегда
      uses: peaceiris/actions-gh-pages@v4  # Используем GitHub Action для публикации отчёта на GitHub Pages
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}  # Токен для аутентификации на GitHub
        publish_branch: gh-pages  # Указываем, что отчёт будет опубликован в ветке gh-pages
        publish_dir: allure-history  # Указываем папку, которая будет опубликована на GitHub Pages

Что происходит:
Этот шаг публикует отчёт, сгенерированный на предыдущем шаге, на GitHub Pages. GitHub Pages — это сервис для хостинга веб-страниц прямо из репозитория.
 - github_token — секретный токен, который используется для аутентификации на GitHub и позволяет выполнять операции с репозиторием.
 - publish_branch — указывает ветку gh-pages, куда будет отправлен отчёт.
 - publish_dir — указывает на папку с результатами (allure-history), которая будет опубликована.
В результате, отчёт будет доступен по URL, связанному с репозиторием, и его можно будет просматривать в браузере. Пока URL для просмотра не доступен, потому что мы еще не опубликовали изменения на GitHub, но это сделаем в следующем шаге


-------------------------------
3. Адаптируем настройки под запуск на CI/CD
-------------------------------
Также перед запуском автотестов нам необходимо разрешить использование дополнительных переменных окружения с помощью библиотеки pydantic-settings. Это нужно, чтобы в переменных окружения могли быть не только те переменные, которые ожидает наша модель Settings, но и другие, которые могут быть полезны для работы серверной части или CI/CD процесса.

Зачем это нужно?
По умолчанию, если наша модель ожидает переменные, такие как TEST_A, TEST_B, но в окружении присутствуют и другие переменные, например, TEST_C, pydantic-settings выбросит ошибку. Это происходит потому, что дополнительные переменные не разрешены по умолчанию. В случае, если мы передаем переменные для работы с сервером:

- name: Start a test server
  env:
    APP_HOST: "http://localhost:8000"
    DATABASE_URL: "sqlite+aiosqlite:///./local.db"
    JWT_ALGORITHM: "HS256"
    JWT_SECRET_KEY: "qa-automation-engineer-api-course-secret-key"
    JWT_ACCESS_TOKEN_EXPIRE: 1800
    JWT_REFRESH_TOKEN_EXPIRE: 5184000
Нам необходимо разрешить передачу дополнительных переменных, чтобы они не приводили к ошибкам при запуске. Для этого добавим параметр extra='allow' в настройки модели Settings. Чтобы сделать это, откроем файл config.py и добавим следующий код:

# Остальной код без изменений

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        extra='allow',  # Разрешаем дополнительные переменные
        env_file=".env",
        env_file_encoding="utf-8",
        env_nested_delimiter=".",
    )

    # Остальной код без изменений


Теперь, если в переменных окружения окажутся дополнительные переменные, помимо тех, которые требует модель Settings, ошибки не будет. Эта настройка крайне важна, иначе автотесты не запустятся на CI/CD.