Покрытие по требованиям (Requirements Coverage)
Следующий тип покрытия — по требованиям. Суть подхода заключается в том, чтобы соотнести бизнес-требования (например, из Confluence, Notion, Google Docs или Jira) с написанными автотестами. Это позволяет получить прозрачную картину того, какие бизнес-функции протестированы, а какие — ещё нет.

Визуально это может быть оформлено по-разному: в виде таблицы, документа, матрицы — строгого стандарта нет. Один из самых простых примеров выглядит так:

Требование	                                |     Тесты
______________________________________________________________
Отображение аккаунтов                       |    1. Получить список аккаунтов
                                            |    2. Создать новый аккаунт
______________________________________________________________
Поиск по операциям                          |    1. Создать операции и выполнить поиск по сумме
______________________________________________________________
Отображение физических и виртуальных карт   |    1. Cоздать виртуальную карту
                                            |    2. Создать физическую карту
_______________________________________________________________
Отображение кешбэка	                        |    —
_______________________________________________________________
Итоговое покрытие: 75%


Важно! Пример выше — максимально упрощённый. В реальных проектах бизнес-требований может быть сотни или даже тысячи, и визуальное представление покрытия становится значительно более громоздким.

Плюсы подхода:
1. Наглядность с точки зрения бизнес-логики. Таблица или матрица требований показывает прямую связь между фичей и тестами. Это значит, что если у проджект-менеджера или аналитика возникает вопрос: «Покрыт ли у нас автотестами поиск по операциям?» — мы спокойно открываем таблицу и видим: да, покрыт таким-то тестом. Никакой двусмысленности, всё чётко.
2. Понятность и доступность для всей команды. Такой вид покрытия могут читать и понимать все роли в команде — от разработчиков до ручных тестировщиков, от аналитиков до менеджеров. Это повышает уровень коммуникации и общую прозрачность качества продукта.

Минусы подхода:
1. Сложность поддержки в актуальном состоянии. Самый критичный минус. Такой отчёт, как правило, создаётся вручную, и у него всегда есть время жизни: от пары часов до пары недель. Как только появляется новое требование — его нужно сразу внести в таблицу. Как только появился новый автотест — его нужно привязать. Если это не сделать вовремя, таблица теряет актуальность, и доверие к ней снижается.
2. Сложность реализации на больших проектах. В реальности требований может быть очень много — в десятки или даже сотни страниц. В такой ситуации таблица становится огромной, её трудно читать, а поддерживать — ещё сложнее. Это приводит к устареванию и потере смысла отчёта.
3. Человеческий фактор. При ручном ведении всегда существует риск: забыли добавить новый тест, забыли удалить устаревшее требование, кто-то переименовал фичу и не обновил связку. Особенно если человек, ответственный за покрытие, переключается между задачами — шанс упустить что-то возрастает.
4. Отсутствие единого формата требований. Часто требования оформляются разными людьми и хранятся в разных местах: в Confluence, Jira, Notion, Google Docs или вообще в переписках и чатах. Без централизации и стандартизации невозможно собрать полное и точное покрытие — сначала нужно привести в порядок сами требования, что уже само по себе непросто.
5. Неактуальность в условиях быстрого темпа. В быстро развивающемся проекте требования могут появляться ежедневно, а иногда и по нескольку раз в день. В таких условиях поддержание актуального покрытия становится практически нереалистичным, если только не выделять на это отдельного человека или команду.



Покрытие по требованиям через систему управления тестами (TMS)
Выше мы рассмотрели ручной способ отображения покрытия по требованиям — в виде таблицы. Но существует и ещё один популярный способ: измерение покрытия через системы управления тестами (Test Management Systems, TMS), такие как Allure TestOPS, TestRail, Qase и другие.

Как это работает?
Принцип очень простой:

У вас в системе заведены, например, 100 тест-кейсов.
Из них 70 автоматизировано, а 30 выполняются вручную.
Система автоматически считает: покрытие автоматизацией составляет 70%.
Некоторые TMS также позволяют привязывать тест-кейсы к бизнес-требованиям или user story, что теоретически позволяет выстроить матрицу покрытия требования → тесты → автоматизация.

Преимущества такого подхода:
1. Простота. Не нужно вести отдельные документы или таблицы. Всё хранится централизованно в одной системе. В Allure TestOps, например, можно настроить визуализацию покрытия в виде графиков и дашбордов, которые обновляются автоматически.
2. Наглядность. Можно быстро увидеть:
    - Какие требования/фичи покрыты тестами
    - Какие тесты автоматизированы
    - Где остались только ручные проверки
3. Доступность всей команде. Такой формат понятен и доступен абсолютно всем — от тестировщиков до бизнес-аналитиков и менеджеров. Не нужно объяснять, что означает какая-то таблица — все видят привычный TMS-интерфейс.


Недостатки подхода (всё те же, что и у ручных таблиц):
1. Сложность в поддержке.
    - Чтобы данные в системе были актуальны, необходимо постоянно создавать и обновлять ручные тест-кейсы, даже если они будут «заглушками» или пустышками.
    - Каждое новое требование нужно отразить в виде тест-кейса — и кто-то должен это делать.
    - При большом объёме требований это превращается в рутинную и трудоёмкую задачу, особенно если бизнес-логика постоянно меняется.
2. Сложность синхронизации автотестов и ручных кейсов. В теории всё выглядит красиво: ручные тестировщики заводят тест-кейсы, автоматизаторы пишут автотесты, и система показывает общее покрытие. Но на практике:
    - Один ручной тест может охватывать сразу целую бизнес-сцену
    - Автотестов на ту же фичу может быть десяток, так как они должны быть атомарными. Сопоставить их друг с другом — сложно. Это требует выработки стандартов, регламентов и процесса — что увеличивает сложность и нагрузку на команду.
3. Необъективность покрытия. Сам факт наличия 100 тестов, из которых 70 — автотесты, не означает, что покрытие требований составляет 70%. Это лишь отражение покрытия тех требований, которые были формализованы и заведены в систему. Если в реальности требований к системе — тысяча, а вы описали только сто, то ваше фактическое покрытие — всего 7%, а не 70%. Именно поэтому такой способ может вводить в заблуждение.



Общий вывод
Все подходы, где ключевую роль играет человеческий фактор — будь то ручные таблицы или TMS — страдают от схожих проблем:

Высокая сложность поддержки
Неактуальность данных
Невозможность автоматической валидации
Субъективность и отсутствие объективной метрики
Как тогда измерять покрытие требований?
А что если объединить лучшее из всех подходов?

Чтобы ничего не нужно было делать руками
Чтобы покрытие считалось автоматически
Чтобы оно было привязано к реальным бизнес-требованиям
И чтобы результат был объективным и прозрачным
Такой подход действительно возможен. Именно его мы и разберём в следующем уроке — через инструмент, который позволяет измерять покрытие Swagger-спецификаций автоматически. Это инструмент swagger-coverage-tool, и он позволяет следить за покрытием на уровне API и требований, а не кода.