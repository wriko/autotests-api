Знакомство с инструментом Swagger Coverage Tool

В этом уроке мы разберём, как измерять покрытие API тестами не вручную, а автоматически — с помощью инструмента swagger-coverage-tool. Этот инструмент предназначен специально для анализа покрытия HTTP API, основываясь на Swagger (OpenAPI) спецификации. Его основная задача — автоматически показать, насколько полно ваши автотесты покрывают описанные в Swagger-е бизнес-функции.

================================================
Концепция: как появился swagger-coverage-tool
================================================
Мы уже знакомы с двумя основными подходами к измерению покрытия:

Тип покрытия
Преимущества	Недостатки
Покрытие по коду (code coverage)
Автоматизируется на 100%
Встроен в большинство CI/CD систем
Не отражает покрытие бизнес-логики
Покрывает код, но не функциональность


Покрытие по требованиям (requirements coverage)
Показывает, какие бизнес-функции протестированы
Требует ручной поддержки
Быстро устаревает
Зависит от человеческого фактора


Каждый из этих подходов хорош по-своему, но имеет свои недостатки. А что если объединить их сильные стороны?

Именно такую задачу решает инструмент swagger-coverage-tool:

Он собирает покрытие автоматически, как в случае с code coverage.
Но при этом основывается на Swagger-документации, которая описывает бизнес-функциональность API — а значит, приближена к реальным требованиям.
Почему Swagger?
Swagger (он же OpenAPI) — это де-факто стандарт для описания REST API. Он:

Машиночитаемый
Поддерживается всеми популярными фреймворками
Может генерироваться автоматически на основе серверного кода
Служит источником истины при разработке и тестировании API
Если в вашем проекте используется Swagger, это значит, что у вас уже есть структурированная спецификация всех эндпоинтов: какие методы есть, какие параметры принимает API, какие возвращает статусы и структуры данных. Именно это делает Swagger идеальной основой для автоматизированного измерения покрытия.

Как это работает?
Представим, что у вас есть:

Swagger-документация, описывающая API
Автотесты, которые вызывают эти API
Инструмент swagger-coverage-tool позволяет:

Отслеживать, какие именно эндпоинты, методы и параметры реально были вызваны тестами
Сравнивать эти вызовы со спецификацией
Автоматически считать процент покрытия
В результате вы получаете покрытие не кода, и не вручную созданных таблиц, а контракта API — с высокой точностью и актуальностью.

Ограничения инструмента
Стоит понимать, что swagger-coverage-tool не способен охватить всё. Он работает строго на уровне API-контрактов. А значит:

Не покажет покрытие внутренней бизнес-логики, связанной с кешами, очередями (Kafka, RabbitMQ), асинхронными задачами, стримингами и другим.
Не определит покрытие условий, ветвлений, сложных сценариев на бэкенде
Но отлично справляется с покрытием API как контракта — на уровне эндпоинтов, параметров, ответов и статус-кодов
Этот инструмент — не замена всем видам покрытия, а инструмент дополнения, который позволяет закрыть один из важнейших уровней: контрактное покрытие API.

Идеальный баланс
swagger-coverage-tool позволяет достичь золотой середины:

Не требует ручного создания таблиц покрытия
Не зависит от IDE и кода на сервере
Поддерживается и в CI/CD, и локально
Основан на документации, которая и так должна быть актуальной
Именно это делает его полезным в реальных проектах, особенно там, где автотесты развиваются параллельно с API.

Про историю инструмента
Инструмент swagger-coverage-tool я разработал сам, вдохновившись предыдущим опытом создания похожего решения для gRPC — tests-coverage-tool.

tests-coverage-tool написан на Go и позволяет измерять покрытие gRPC API, используя серверную рефлексию.
Подходит для проектов, где автотесты реализованы на Golang, и API описан в .proto файлах.
Он работает по той же концепции — сравнение фактических вызовов с описанием API (в данном случае, gRPC контрактом).
Таким образом, swagger-coverage-tool и tests-coverage-tool — это два родственных инструмента, которые дают возможность контрактного покрытия API в зависимости от используемой технологии: REST или gRPC.

Схема работы
Работа инструмента swagger-coverage-tool построена на простом и понятном пайплайне. Вся система делится на несколько последовательных этапов:

Установка. Устанавливаем инструмент в проект, подключаем необходимые зависимости.
Настройка. Конфигурируем путь до Swagger-спецификации, директорию для сохранения результатов, нужные параметры трекинга и другие настройки.
Сбор фактического покрытия. Каждый раз при выполнении запроса к API (во время тестов или в рантайме) инструмент сохраняет результат в специальную директорию ./coverage-results. Эти данные включают:

Эндпоинт
Метод запроса
Параметры
Тело запроса/ответа
Статус-код
Загрузка Swagger-схемы и сравнение с фактами. После завершения тестов инструмент загружает Swagger-документацию и сравнивает спецификацию с тем, что реально было вызвано. Таким образом формируется покрытие спецификации.
Генерация отчёта. На последнем этапе строится подробный HTML-отчёт, где видно:

Какие эндпоинты покрыты
Какие параметры и поля ответа были задействованы
Где есть пробелы в покрытии
Вся схема максимально проста и интуитивна — фактически, всё, что вам нужно, это запустить тесты и собрать факты, всё остальное swagger-coverage-tool сделает за вас.



Отчёт покрытия
Инструмент swagger-coverage-tool генерирует наглядный и легко читаемый HTML-отчёт, с которым может работать любой человек, знакомый со Swagger-документацией. Даже если вы впервые сталкиваетесь с анализом покрытия, отчёт интуитивно понятен и содержит всё необходимое для анализа.

Давайте разберём, из чего состоит HTML-отчёт и как правильно его читать.

Основные виджеты
Сразу после открытия отчёта вы увидите три ключевых виджета в верхней части страницы:

Config
Total service coverage
Total service coverage history

1. Config
Виджет Config отображает метаинформацию, связанную с отчётом:

Service name — имя сервиса, по которому собиралось покрытие. Особенно важно в микросервисной архитектуре, где у каждого сервиса своя Swagger-документация. Помогает понять, к какому именно сервису относится текущий отчёт.
Repository — ссылка на репозиторий сервиса. Удобно для быстрой навигации и сопоставления с кодовой базой.
Swagger JSON URL — ссылка на спецификацию Swagger в формате JSON. Это обязательное поле, так как swagger-coverage-tool работает напрямую с JSON-версией спецификации.

Важно! указывается именно JSON, а не Swagger UI. Например:
Swagger UI: http://localhost:8000/docs
Swagger JSON: http://localhost:8000/openapi.json
Swagger file path — альтернатива ссылке: путь к локальному Swagger JSON-файлу. Полезно в CI/CD средах или Kubernetes, где внешний доступ ограничен.
Report created at — дата и время генерации текущего отчёта. Позволяет отслеживать, насколько отчёт актуален.
2. Total Service Coverage
Этот виджет показывает общее покрытие API-сервиса в процентном выражении.

Принцип расчёта очень простой: Допустим, в спецификации указано 100 эндпоинтов, а тестами покрыто только 30 — итоговое покрытие будет 30%. Оставшиеся 70 считаются непокрытыми и подсвечиваются соответствующим образом в деталях отчёта.

3. Total Service Coverage History
Total service coverage history — это график, отображающий историю изменения покрытия во времени.

Зачем он нужен?

Позволяет отслеживать динамику покрытия.
Помогает увидеть прогресс команды: например, вчера было 50%, сегодня уже 70%.
Позволяет заметить просадки: если после добавления новых эндпоинтов покрытие упало — это сигнал, что необходимо добавить соответствующие API тесты.
История особенно полезна на длинной дистанции, когда покрытие развивается вместе с проектом.

Список эндпоинтов
Ниже в HTML-отчёте отображается полный список эндпоинтов, взятый из Swagger-документации. Это тот же самый список, который вы видите при просмотре Swagger UI, только теперь он дополнен информацией о фактическом покрытии API тестами.

Список представлен в виде интерактивной таблицы, где каждый ряд соответствует одному API-методу.



Рассмотрим подробнее, что означает каждая колонка в таблице:

Method.  Показывает HTTP-метод, с которым вызывается данный эндпоинт: GET, POST, PUT, DELETE и другие. Позволяет быстро понять, какой тип запроса используется для каждого маршрута.
Endpoint. Отображает сам путь эндпоинта, например:
/users/{id}
/auth/login
/products
Позволяет быстро идентифицировать, о каком маршруте идёт речь.

Covered? Показывает, был ли данный эндпоинт вообще покрыт. То есть — был ли он вызван хотя бы один раз в процессе выполнения автотестов.

Важно! Эндпоинт может быть помечен как покрытый, даже если покрытие не полное. Например, если вызов был, но не были проверены все возможные статусы ответа — он всё равно будет отображаться как покрытый, но с неполным процентом покрытия (см. колонку Total coverage).

Total cases. Отображает общее количество вызовов к данному эндпоинту. Зачем это нужно:

Помогает понять, какие эндпоинты тестируются чаще всего
Какие, наоборот, забыты и требуют внимания
Позволяет сделать приоритизацию по реальной активности
Total coverage. Отображает процентное покрытие данного эндпоинта. Расчёт включает в себя сразу несколько факторов:

Наличие запроса. Если эндпоинт принимает тело запроса (например, в POST или PUT), то хотя бы один вызов должен содержать непустой request body.
Статус-коды ответов. Swagger-документация описывает, какие статус-коды может возвращать эндпоинт (200, 400, 404, и другие). Для каждого из них ожидается, что будет зафиксирован хотя бы один реальный ответ с соответствующим телом (если оно описано в Swagger).
Query-параметры. Если эндпоинт принимает параметры в URL (?limit=10&offset=20), то в покрытие также включается информация о том, были ли переданы эти параметры в фактических вызовах.
Каждая колонка в таблице поддерживает сортировку. Это крайне удобно:

можно отсортировать по Total coverage, чтобы увидеть непокрытые или частично покрытые эндпоинты
отфильтровать по Covered?, чтобы найти пропущенные маршруты
отсортировать по Total cases, чтобы понять, какие методы вызываются чаще всего
Это позволяет быстро делать выводы и принимать решения по доработке тестов.

Детали эндпоинта
swagger-coverage-tool позволяет заглянуть внутрь каждого эндпоинта и увидеть, что именно было покрыто, а что — нет. Это особенно полезно для анализа качества и полноты тестов.

Для каждого эндпоинта доступна модалка (всплывающее окно) с детальной информацией.



Общая информация
В верхней части окна с деталями эндпоинта отображаются основные метаданные:

HTTP-метод (GET, POST и т.д.)
Путь эндпоинта (/users/{id} и т.п.)
Информация о покрытии:
Был ли отправлен запрос с непустым телом
Были ли проверены статус-коды
Были ли переданы query-параметры
Если, например, эндпоинт не принимает тело запроса (типично для GET), то в поле "Request Body" будет отображаться синяя иконка — это означает, что тело не требуется, и его отсутствие не влияет на покрытие.

Вкладка History
На этой вкладке отображается история покрытия конкретного эндпоинта. Зачем это нужно:

Позволяет отследить изменения покрытия во времени
Например, если в эндпоинт был добавлен новый status code или query-параметр, то общее покрытие автоматически снизится
Это сразу отразится как на графике, так и в проценте Total coverage
Пример: Допустим, GET /transactions принимает 5 query-параметров: user_id, account_id, operation_id, card_id, document_id. Все они покрыты, и покрытие составляет 100%. После этого добавляется новый параметр statement_id.
Покрытие автоматически снижается до 85%, и это видно в графике. Это сигнал для команды: нужно дописать API тест, чтобы снова вернуть полное покрытие.

Вкладка Coverage
Здесь содержится таблица, разбитая на несколько блоков, каждый из которых отвечает за отдельную часть спецификации:

Покрытие Query-параметров
Если эндпоинт поддерживает множество параметров в URL (обычно в GET запросах для фильтрации и поиска), то:

Каждый параметр анализируется отдельно
Видно, какие параметры были реально переданы в запросах
Какие — не использовались, а значит не покрыты тестами
Важно! Непроверенные query-параметры могут быть источником багов. Поэтому важно добиваться максимального покрытия особенно в поисковых/фильтрационных API.

Покрытие статус-кодов
Каждый статус-код, указанный в Swagger-документации, также отображается в виде таблицы:

Считается покрытым, если был получен хотя бы один ответ с таким кодом
Показывается общее количество таких ответов
Для каждого кода отображается тело ответа (если оно предполагается)
Если статус-код не содержит тела ответа, то отображается синяя иконка — как и в случае с телом запроса, такой код не влияет на процент покрытия тела ответа.

Это даёт максимально прозрачную картину — какие ответы тестировались, а какие — остались неохваченными.

Гибкость и автоматизация
Один из ключевых плюсов инструмента — отсутствие необходимости вручную обновлять спецификацию или отчёт:

Например, если принято решение протестировать авторизацию (401 Unauthorized) на всех эндпоинтах
А в Swagger-документации эти коды не указаны — это не проблема
Разработчики добавляют 401 через серверную логику (обычно это общее middleware)
Swagger автоматически обновляется, и в отчёте появляются новые строки
Инструмент сам покажет, где ещё не хватает покрытых 401
Таким образом, вы всегда будете видеть актуальную картину, не делая ничего вручную.

Кейсы использования
Инструмент swagger-coverage-tool можно применять в самых разных ситуациях — от разработки автотестов до ревью и планирования. Вот основные сценарии, в которых он особенно полезен:

1. Оценка текущего покрытия
Вы написали набор API-тестов и хотите понять, насколько хорошо они покрывают функциональность сервиса. Просто запускаете тесты, открываете отчёт, и видите:

какие эндпоинты были вызваны;
какие параметры использовались;
какие статус-коды проверялись;
какие части спецификации остались без внимания.
Это позволяет объективно оценить уровень покрытия, а не ориентироваться на ощущения или количество тестов.

2. Проведение ревью автотестов
Инструмент можно использовать прямо в процессе ревью автотестов. Например:

в проекте появился новый эндпоинт;
коллега написал тесты для него;
после запуска вы открываете отчёт и смотрите, все ли параметры покрыты, не забыли ли про статус 401, и другие.
Это быстрый и наглядный способ убедиться, что ничего не упущено — особенно когда ручное ревью становится слишком громоздким.

3. Приоритезация и постановка задач
swagger-coverage-tool можно использовать для анализа покрытия и формирования задач в бэклог. Например:

вы открываете свежий отчёт и видите, что 40% эндпоинтов не покрыто вообще;
у части — не покрыты query-параметры;
где-то нет проверок на 5xx коды.
На основе этих данных:

можно создавать задачи на написание тестов;
назначать приоритеты — критичные, если совсем не покрыты, или средние, если покрытие частичное;
планировать итерации по улучшению покрытия.
4. Демонстрация команде и заказчику
Интеграция отчёта с CI или документацией позволяет визуально показать, какие части API тестируются, а какие — нет.

Например, когда кто-то спрашивает:

“А у нас покрыт поиск по банковским операциям?”

Теперь можно не гадать, а открыть отчёт и сказать:

“Да, покрыт. Протестированы такие-то параметры, проверяются коды 200, 404 и 401, тело запроса и ответы проверены на полноту.”

Это прозрачность и доверие к автотестам — важный элемент качественного и зрелого процесса тестирования.