Добавление allure.step в APIClient

Начнем с добавления Allure шагов на низком уровне, а именно в APIClient.
Все наши API автотесты выполняют запросы через этот клиент, поэтому важно, чтобы в отчете отображалась следующая информация:

 - Какие HTTP-запросы отправлялись (методы и URL).
 - На какие эндпоинты были отправлены запросы.
 - Какие параметры использовались в запросах (например, тело запроса в POST).

Таким образом, в отчете Allure мы сразу будем видеть ключевые детали каждого HTTP-взаимодействия.

_____________________________________
Добавление шагов в APIClient
_____________________________________
Откроем файл /clients/api_client.py и добавим Allure шаги к основным HTTP-методам:

    from typing import Any

    import allure  # Импортируем allure
    from httpx import Client, URL, Response, QueryParams
    from httpx._types import RequestData, RequestFiles


    class APIClient:
        def __init__(self, client: Client):
            self.client = client

        @allure.step("Make GET request to {url}")  # Добавили allure шаг
        def get(self, url: URL | str, params: QueryParams | None = None) -> Response:
            # Остальной код без изменений

        @allure.step("Make POST request to {url}")  # Добавили allure шаг
        def post(
                self,
                url: URL | str,
                json: Any | None = None,
                data: RequestData | None = None,
                files: RequestFiles | None = None
        ) -> Response:
            # Остальной код без изменений

        @allure.step("Make PATCH request to {url}")  # Добавили allure шаг
        def patch(self, url: URL | str, json: Any | None = None) -> Response:
            # Остальной код без изменений

        @allure.step("Make DELETE request to {url}")  # Добавили allure шаг
        def delete(self, url: URL | str) -> Response:
            # Остальной код без изменений

Зачем это нужно?
Использование APIClient как базового класса для отправки HTTP-запросов — мощное и гибкое решение. Как только мы добавили шаги в APIClient, при запуске тестов в Allure-отчете появится подробная информация о каждом запросе:
 - В каком тесте он был вызван.
 - Какой URL использовался.
 - Какие параметры передавались.

Фактически, за пару минут мы добавили полную трассируемость взаимодействия с API.

Дальнейшие возможности
Этот подход дает массу преимуществ:

 - можно легко расширять функциональность клиента. Например, если потребуется логирование или изменение настроек запросов, достаточно внести правки в одном месте.
 - Подход гибкий и масштабируемый – можно добавлять новые методы без дублирования кода в тестах.
 - Минимальные изменения в коде – добавление Allure шагов затронуло только APIClient, а весь остальной код остался без изменений.

-------------------------------------------------
Важные моменты при использовании Allure шагов
-------------------------------------------
Шаги оформлены в виде декораторов. Мы используем @allure.step(...) вместо явного вызова allure.step(...) в виде контекстного менеджера.
Это важно, так как в отчете Allure будут видны аргументы методов, например:

json (тело запроса в POST).
params (Query параметры в GET).
url (конечная точка API).
Таким образом, отчет сразу дает полную информацию о переданных данных.

Динамические параметры без кавычек. Мы пишем шаги так:

"Make GET request to {url}" — корректно
"Make GET request to '{url}'" — некорректно, будут дублированные кавычки
Почему? Allure автоматически подставляет кавычки, если аргумент — строка. Поэтому лишние кавычки не нужны, чтобы избежать дублирования в отчете.

------------------------------------
Запускаем автотесты
----------------------------------
Теперь, когда мы добавили Allure шаги, давайте запустим автотесты и посмотрим, как они отобразятся в отчете Allure.

python -m pytest -m "regression" --alluredir=./allure-results
После завершения тестов сгенерируем отчет:

allure serve ./allure-results
В результате откроется Allure-отчет, который будет выглядеть следующим образом:



Что мы видим в отчете?
Благодаря единым точкам входа (APIClient) и грамотному использованию @allure.step в виде декоратора, отчет получился информативным и детализированным.

По нему можно сразу понять:

Куда отправлялся запрос (URL).
Какой HTTP-метод использовался (GET, POST, PATCH, DELETE).
Какие параметры были переданы (query params, headers, тело запроса).
Все ключевые детали автоматически отображаются в отчете без необходимости вручную добавлять их в каждом тесте. Этот подход значительно упрощает анализ API-тестов, делает их прозрачными и легкими в отладке.

Правильное использование allure.step
Важно помнить, что шаги Allure нужно добавлять на уровне методов, таких как APIClient.post, а не непосредственно в тестах. Рассмотрим пример:

class TestCourses:
    def test_create_course(
            self,
            courses_client: CoursesClient,
            function_user: UserFixture,
            function_file: FileFixture
    ):
        request = CreateCourseRequestSchema(
            preview_file_id=function_file.response.file.id,
            created_by_user_id=function_user.response.user.id
        )
        with allure.step("Make POST request to /api/v1/courses"):
            response = courses_client.create_course_api(request)
        response_data = CreateCourseResponseSchema.model_validate_json(response.text)
Почему это неправильно?
Хотя кажется удобным добавлять шаги прямо в тесте, такой подход приведет к излишнему дублированию кода и ухудшит поддерживаемость автотестов. Шаги нужно выносить в методы API клиентов или базовые функции, что делает код чище и упрощает сопровождение.

Также если над проектом работают сразу несколько команд расстановка шагов в тестах также может привести к большим проблемам в будущем, потому что сложно будет синхронизировать большое количество QA Automation Engineer-ов чтобы каждый писал одинаковые шаги - все будут писать так, как им хочется. По итогу отчеты превратятся в хаос и пользы от них не будет никакой. Один и тот же тест может выглядеть абсолютно по разному в таких проектах. И это потом приводит к тому, что люди дублируют один и те же тесты, просто потому что не смогли разобраться в том, что именно проверяет тот или иной тест. Теряется универсальность и еще многое другое. А можно было бы просто принять правильное решениен6 как это сделали мы

Рекомендации:
 - Используйте шаги на уровне методов. Это позволяет сократить дублирование кода и обеспечит, что каждый шаг будет правильно отражен в отчете.
 - Не злоупотребляйте явным добавлением шагов в тестах. Добавление шагов непосредственно в тестах может усложнить их логику и привести к хаосу в отчетах.
 - Поддерживайте структуру отчета. Благодаря правильному добавлению шагов, отчет становится более наглядным и позволяет быстрее находить возможные проблемы.