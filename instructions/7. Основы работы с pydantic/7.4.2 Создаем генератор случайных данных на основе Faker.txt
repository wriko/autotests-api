Создаем генератор случайных данных на основе Faker

В этом уроке мы создадим обертку над библиотекой Faker, чтобы инкапсулировать логику работы с ней в нашем проекте. Этот подход имеет несколько ключевых преимуществ.
Так же, как мы поступали при валидации JSON схемы, создавая функцию validate_json_schema, мы создадим обертку над Faker. Это позволит нам скрыть детали работы с библиотекой и вынести их в отдельный класс или модуль.
Если в будущем мы решим сменить библиотеку для генерации случайных данных или изменить логику их создания, нам придется менять код только в обертке, а не по всему проекту. Это значительно снижает риски и ускоряет разработку.

На практике такая обертка — это очень распространенный подход, который часто используется в реальных проектах. Часто при использовании сторонней библиотеки возникают так называемые breaking changes.
Это когда, например, в новой версии библиотеки удаляются какие-то классы или функции, которые использовались в вашем коде. В случае обновления библиотеки и появления таких изменений весь ваш код, который использует эти функции, может перестать работать.
Если вы напрямую используете функции библиотеки в разных частях вашего проекта, вам придется переписывать весь код, чтобы адаптироваться к новым изменениям.

Однако, если у вас есть обертка над библиотекой, то изменения касаются только кода этой обертки, и вам не нужно будет переписывать код во всем проекте. Таким образом, вы обеспечиваете большую гибкость и минимизируете риски при обновлениях сторонних зависимостей.
-------------------------------
1. Создаем класс Fake
-------------------------------
Напомню, что у нас уже есть файл /tools/fakers.py, внутри которого мы создавали функцию get_random_email, которая генерировала случайный емейл на основе timestamp. Теперь мы будем выполнять всю генерацию тестовых данных используя Faker. Давайте удалим функцию get_random_email и вместо нее добавим следующий код:

    from faker import Faker


    class Fake:
        """
        Класс для генерации случайных тестовых данных с использованием библиотеки Faker.
        """

        def __init__(self, faker: Faker):
            """
            :param faker: Экземпляр класса Faker, который будет использоваться для генерации данных.
            """
            self.faker = faker

        def text(self) -> str:
            """
            Генерирует случайный текст.

            :return: Случайный текст.
            """
            return self.faker.text()

        def uuid4(self) -> str:
            """
            Генерирует случайный UUID4.

            :return: Случайный UUID4.
            """
            return self.faker.uuid4()

        def email(self) -> str:
            """
            Генерирует случайный email.

            :return: Случайный email.
            """
            return self.faker.email()

        def sentence(self) -> str:
            """
            Генерирует случайное предложение.

            :return: Случайное предложение.
            """
            return self.faker.sentence()

        def password(self) -> str:
            """
            Генерирует случайный пароль.

            :return: Случайный пароль.
            """
            return self.faker.password()

        def last_name(self) -> str:
            """
            Генерирует случайную фамилию.

            :return: Случайная фамилия.
            """
            return self.faker.last_name()

        def first_name(self) -> str:
            """
            Генерирует случайное имя.

            :return: Случайное имя.
            """
            return self.faker.first_name()

        def middle_name(self) -> str:
            """
            Генерирует случайное отчество/среднее имя.

            :return: Случайное отчество.
            """
            return self.faker.first_name()

        def estimated_time(self) -> str:
            """
            Генерирует строку с предполагаемым временем (например, "2 weeks").

            :return: Строка с предполагаемым временем.
            """
            return f"{self.integer(1, 10)} weeks"

        def integer(self, start: int = 1, end: int = 100) -> int:
            """
            Генерирует случайное целое число в заданном диапазоне.

            :param start: Начало диапазона (включительно).
            :param end: Конец диапазона (включительно).
            :return: Случайное целое число.
            """
            return self.faker.random_int(start, end)

        def max_score(self) -> int:
            """
            Генерирует случайный максимальный балл в диапазоне от 50 до 100.

            :return: Случайный балл.
            """
            return self.integer(50, 100)

        def min_score(self) -> int:
            """
            Генерирует случайный минимальный балл в диапазоне от 1 до 30.

            :return: Случайный балл.
            """
            return self.integer(1, 30)


    # Создаем экземпляр класса Fake с использованием Faker
    fake = Fake(faker=Faker())

------------------------------------
Разбор кода
------------------------------------

1. Создание класса Fake:
Мы создаем класс Fake, который инкапсулирует логику работы с библиотекой Faker. Этот класс будет использоваться для генерации случайных данных, таких как имена, email, пароли, и другие элементы.

2. Конструктор класса __init__:
Конструктор класса принимает один параметр — экземпляр класса Faker. Это даёт нам гибкость для работы с различными языками или провайдерами данных, просто передав другой экземпляр Faker с нужной настройкой.

3. Методы для генерации данных:
Каждый метод класса Fake вызывает соответствующий метод из библиотеки Faker для генерации случайных данных:
 - text(): Генерирует случайный текст.
 - uuid4(): Генерирует случайный UUID4.
 - email(): Генерирует случайный email.
 - sentence(): Генерирует случайное предложение.
 - password(): Генерирует случайный пароль.
 - last_name(): Генерирует случайную фамилию.
 - first_name(): Генерирует случайное имя.
 - middle_name(): Генерирует случайное отчество.
 - estimated_time(): Генерирует строку с предполагаемым временем (например, "3 weeks").

4. Методы для генерации случайных чисел:

Мы создаем методы integer(), max_score(), и min_score(), которые генерируют случайные целые числа в заданных диапазонах.
 - integer() генерирует случайное целое число в диапазоне от start до end.
 - max_score() и min_score() генерируют случайные баллы в специфичных диапазонах.

5. Создание экземпляра fake:

В конце создается экземпляр класса Fake, инициализированный экземпляром Faker(). Это позволяет нам использовать методы класса Fake для генерации случайных данных в проекте.


Почему это полезно?

Этот подход предоставляет множество преимуществ:
1. Масштабируемость: Мы можем легко настроить генератор случайных данных под разные языки и провайдеров, передав другой экземпляр Faker в конструктор.
2. Устойчивость: При изменении логики генерации данных или при смене библиотеки для генерации случайных данных, нам нужно будет менять только код в классе Fake, а не по всему проекту.
3. Чистота и читаемость кода: Обертка делает код чище и проще для восприятия, так как все вызовы к библиотеке Faker централизованы в одном месте.

При создании обертки важно не только инкапсулировать логику работы с библиотеками, но и предусматривать возможность масштабирования и удобства изменения логики в будущем.
Такая архитектура позволяет легко адаптировать проект под изменения внешних зависимостей, не влияя на основную логику работы приложения.

-------------------------------------------------
2. Заменяем get_random_email на fake.email
-------------------------------------------------
В предыдущем шаге мы удалили функцию get_random_email, которая использовалась для генерации случайных электронных адресов. Теперь нам необходимо заменить ее использование на fake.email() во всех местах в коде.

Файлы, в которых нужно внести изменения:
api_client_get_user.py
apI_client_create_course.py
api_client_create_exercise.py
httpx_get_user.py
httpx_create_file.py
httpx_create_user.py
httpx_update_user.py
https_delete_user.py
pydantic_json_schema_get_user.py
pydantic_json_schema_create_user.py
Давайте рассмотрим, как заменить get_random_email() на fake.email() на примере файла httpx_create_user.py:

import httpx

# Вместо get_random_email импортируем fake
from tools.fakers import fake

payload = {
    "email": fake.email(),  # Вместо get_random_email() используем fake.email()
    "password": "string",
    "lastName": "string",
    "firstName": "string",
    "middleName": "string"
}
response = httpx.post("http://localhost:8000/api/v1/users", json=payload)

print(response.status_code)
print(response.json())
Какие изменения мы внесли?
Импорт: Заменили from tools.fakers import get_random_email на from tools.fakers import fake.
Использование: В коде заменили get_random_email() на fake.email().
Как заменить во всем проекте автоматически
Вам не обязательно вручную проходить по каждому файлу и вносить изменения. Такие простые замены можно выполнять автоматически с помощью возможностей вашей IDE. Мы используем PyCharm, поэтому выполним следующую команду для массовой замены:

Горячие клавиши для вызова интерфейса замены в PyCharm:

macOS: Command + Shift + R
Windows/Linux: Ctrl + Shift + R
После выполнения данной команды откроется интерфейс поиска и замены.

В поле Search введите: from tools.fakers import get_random_email
В поле Replace введите: from tools.fakers import fake
Нажмите Replace All


Теперь повторите операцию:

В поле Search введите: get_random_email()
В поле Replace введите: fake.email()
Нажмите Replace All
После этих действий вся замена будет выполнена автоматически.

Важно! После массовой замены в коде могут остаться лишние пробелы. Пройдитесь по измененным файлам и убедитесь, что перед fake.email() не осталось пробелов. Это особенно важно, если использовался автозаменитель в IDE, так как он может оставить лишние символы после удаления старого кода.

Если же вам удобнее, вы можете пройтись по каждому файлу вручную и внести изменения самостоятельно.