В этом шаге мы настроим небольшой gRPC-сервер, реализуем его обработчики и создадим клиент, чтобы на практике разобраться в работе данного протокола, изучить его основные принципы и особенности взаимодействия.
========================================================================================================================
                                Установка gRPC в Python
========================================================================================================================
Перед началом работы необходимо установить библиотеки:
    pip install grpcio grpcio-tools

========================================================================================================================
                        Установка protoc (Protocol Buffers Compiler)
========================================================================================================================
Важно! Если у вас возникли ошибки при генерации Python-контрактов из .proto файлов с помощью команды:
    python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. user_service.proto
например:

WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
W0000 00:00:1744097480.307035    7680 parser.cc:686] No syntax specified for the proto file: user_service.proto. Please use 'syntax = "proto2";' or 'syntax = "proto3";' to specify a syntax version. (Defaulted to proto2 syntax.)
user_service.proto:1:1: Expected top-level statement (e.g. "message").
user_service.proto:7:3: Expected "required", "optional", or "repeated".

то возможно у вас не установлен protoc — Protocol Buffers Compiler, или он не добавлен в переменную среды PATH. Если таких ошибок не возникло, то дополнительно protoc устанавливать не нужно.
---------------------------
Установка для Windows
Зайдите на страницу релизов: https://github.com/protocolbuffers/protobuf/releases
Найдите последнюю стабильную версию (например, v21.12 или выше).
Скачайте архив protoc-<version>-win64.zip.
Распакуйте его, например, в C:\tools\protoc\.
Добавьте путь к C:\tools\protoc\bin в переменную среды PATH:
Откройте "Система" → "Дополнительные параметры системы" → "Переменные среды"
Найдите переменную PATH → "Изменить" → "Новая" → вставьте C:\tools\protoc\bin
Проверьте в командной строке:
protoc --version
Должен быть выведен номер версии, например libprotoc 21.12
---------------------------
Установка для macOS
Открываем терминал и устанавливаем через brew:

brew install protobuf
Проверка установки:

protoc --version
---------------------------
Установка для Linux (Ubuntu/Debian)
В терминале выполните:

sudo apt update
sudo apt install -y protobuf-compiler
Проверка:

protoc --version
Если нужна более новая версия — лучше скачать с GitHub (как в инструкции для Windows), распаковать и добавить bin в PATH.
---------------------------
После установки
Теперь можно снова сгенерировать Python-контракты:

    python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. user_service.proto

========================================================================================================================
                            Определение контракта (protobuf)
========================================================================================================================
Для gRPC нам нужен файл .proto, в котором описаны сервисы и сообщения.

В корне проекта autotests-api создадим файл user_service.proto:

.
└── autotests-api/
    └── user_service.proto

Добавим в файл user_service.proto следующий контент:

syntax = "proto3";

package userservice;

// Определяем сообщение запроса
message GetUserRequest {
  string username = 1;
}

// Определяем сообщение ответа
message GetUserResponse {
  string message = 1;
}

// Определяем gRPC-сервис
service UserService {
  // Определяем метод gRPC-сервиса
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}


Этот .proto-файл описывает контракт gRPC-сервиса UserService, который предоставляет метод GetUser. Давайте разберем его подробно по частям.
---------------------------
1. Определение версии Protocol Buffers
syntax = "proto3";
Этот файл использует третью версию (proto3) Protocol Buffers — формата сериализации данных, который используется в gRPC.
---------------------------
2. Определение пакета
package userservice;
Пакет (package userservice;) определяет область видимости сообщений и сервисов. Это помогает избежать конфликтов имен, особенно если в системе используется несколько .proto-файлов.
---------------------------
3. Определение структуры запроса
message GetUserRequest {
  string username = 1;
}
Здесь определено gRPC-сообщение GetUserRequest, которое передается серверу в запросе.

Оно содержит одно поле username, которое представляет собой строку (string).
Число 1 — это метка поля (field number), которая используется для сериализации данных.
---------------------------
4. Определение структуры ответа
message GetUserResponse {
  string message = 1;
}
Это ответ сервера, который отправляется клиенту.

Содержит одно поле message — строка (string).
В этом поле может находиться, например, сообщение с приветствием ("Hello, user123!") или описание ошибки ("User not found").
---------------------------
5. Определение gRPC-сервиса
service UserService {
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
Этот блок определяет gRPC-сервис UserService с одним методом GetUser.

rpc GetUser (GetUserRequest) returns (GetUserResponse);
Метод GetUser принимает GetUserRequest (запрос с username).
Возвращает GetUserResponse (ответ с message).
Таким образом, клиент отправляет имя пользователя, а сервер отвечает, например, приветственным сообщением.

========================================================================================================================
                    Генерация серверного и клиентского кода
========================================================================================================================
Запустите следующую команду для генерации Python-кода из .proto файла:

    python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. user_service.proto

В результате появятся два файла:

user_service_pb2.py — содержит классы сообщений.
user_service_pb2_grpc.py — содержит код для работы с gRPC.

========================================================================================================================
                            Реализация gRPC-сервера
========================================================================================================================
Теперь создадим сервер, который будет обрабатывать входящие gRPC-запросы.

В корне проекта autotests-api создадим файл grpc_server.py, который будет содержать реализацию сервера:

.
└── autotests-api/
    ├── grpc_server.py                # gRPC сервер
    ├── user_service.proto            # Файл с gRPC-контрактом
    ├── user_service_pb2.py           # Сгенерированный Python-код для сообщений
    └── user_service_pb2_grpc.py      # Сгенерированный Python-код для сервиса
Открываем grpc_server.py и добавляем следующий код:

from concurrent import futures  # Импорт пула потоков для асинхронного выполнения

import grpc  # Импорт библиотеки gRPC

import user_service_pb2  # Сгенерированные классы для работы с gRPC-сообщениями
import user_service_pb2_grpc  # Сгенерированный класс для работы с сервисом


# Реализация gRPC-сервиса

class UserServiceServicer(user_service_pb2_grpc.UserServiceServicer):
    """Реализация методов gRPC-сервиса UserService"""

    def GetUser(self, request, context):
        """Метод GetUser обрабатывает входящий запрос"""
        print(f'Получен запрос к методу GetUser от пользователя: {request.username}')

        # Формируем и возвращаем ответное сообщение
        return user_service_pb2.GetUserResponse(message=f"Привет, {request.username}!")


# Функция для запуска gRPC-сервера
def serve():
    """Функция создает и запускает gRPC-сервер"""

    # Создаем сервер с использованием пула потоков (до 10 потоков)
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))

    # Регистрируем сервис UserService на сервере
    user_service_pb2_grpc.add_UserServiceServicer_to_server(UserServiceServicer(), server)

    # Настраиваем сервер для прослушивания порта 50051
    server.add_insecure_port('[::]:50051')

    # Запускаем сервер
    server.start()
    print("gRPC сервер запущен на порту 50051...")

    # Ожидаем завершения работы сервера
    server.wait_for_termination()


# Запуск сервера при выполнении скрипта
if __name__ == "__main__":
    serve()
1. Импорт необходимых модулей
from concurrent import futures  # Импорт пула потоков для асинхронного выполнения

import grpc  # Импорт библиотеки gRPC

import user_service_pb2  # Сгенерированные классы для работы с gRPC-сообщениями
import user_service_pb2_grpc  # Сгенерированный класс для работы с сервисом
Этот блок импортирует:

futures из concurrent — используется для создания пула потоков, который позволяет серверу обрабатывать несколько запросов одновременно.
grpc — основная библиотека для работы с gRPC.
user_service_pb2 — автоматически сгенерированные классы сообщений из .proto-файла.
user_service_pb2_grpc — автоматически сгенерированные классы для сервиса, включая базовый класс UserServiceServicer, который мы будем реализовывать.
2. Определение сервиса
class UserServiceServicer(user_service_pb2_grpc.UserServiceServicer):
    """Реализация методов gRPC-сервиса UserService"""

    def GetUser(self, request, context):
        """Метод GetUser обрабатывает входящий запрос"""
        print(f'Получен запрос к методу GetUser от пользователя: {request.username}')

        # Формируем и возвращаем ответное сообщение
        return user_service_pb2.GetUserResponse(message=f"Привет, {request.username}!")
Этот класс реализует gRPC-сервис UserService, который был определен в user_service.proto.

Наследование от UserServiceServicer

Класс UserServiceServicer унаследован от автоматически сгенерированного класса user_service_pb2_grpc.UserServiceServicer.
Это означает, что мы должны реализовать все методы, объявленные в .proto-файле.
Метод GetUser(self, request, context)

Получает объект запроса (GetUserRequest), который содержит username.
Логирует полученный запрос (print).
Формирует и возвращает ответ (GetUserResponse) с приветственным сообщением
3. Создание и запуск сервера
def serve():
    """Функция создает и запускает gRPC-сервер"""

    # Создаем сервер с пулом потоков (до 10 потоков)
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))

    # Регистрируем сервис UserService на сервере
    user_service_pb2_grpc.add_UserServiceServicer_to_server(UserServiceServicer(), server)

    # Настраиваем сервер для прослушивания порта 50051
    server.add_insecure_port('[::]:50051')

    # Запускаем сервер
    server.start()
    print("gRPC сервер запущен на порту 50051...")

    # Ожидаем завершения работы сервера
    server.wait_for_termination()
Функция serve() выполняет несколько ключевых задач:

Создание gRPC-сервера

Использует grpc.server(), передавая ThreadPoolExecutor(max_workers=10), который позволяет обрабатывать до 10 параллельных запросов.
Регистрация сервиса

Метод add_UserServiceServicer_to_server() связывает наш UserServiceServicer с сервером.
Настройка порта

Сервер будет слушать соединения на 50051 (стандартный порт для gRPC).
server.add_insecure_port('[::]:50051') означает, что сервер будет доступен по всем IP-адресам ([::] — это аналог 0.0.0.0, но для IPv6).
Запуск сервера

server.start() запускает сервер в фоновом режиме.
Ожидание завершения работы

server.wait_for_termination() заставляет программу не завершаться, пока сервер не будет остановлен вручную.
4. Запуск сервера
if __name__ == "__main__":
    serve()
Этот блок кода выполняет serve() только если файл запущен напрямую (а не импортирован как модуль).
Это стандартный прием в Python, предотвращающий непреднамеренный запуск кода при импорте.
Итоговый процесс работы сервера
Клиент отправляет gRPC-запрос GetUser(username="Nikita").
Сервер получает запрос, логирует его и вызывает GetUser().
Метод GetUser() формирует ответ GetUserResponse(message="Привет, Nikita!") и отправляет его клиенту.
Клиент получает ответ.
Теперь сервер можно запустить командой:

python -m grpc_server
Вывод в консоли:

gRPC сервер запущен на порту 50051...
Сервер готов к приему gRPC-запросов!


========================================================================================================================
                        Реализация gRPC-клиента
========================================================================================================================
Теперь создадим клиент, который будет отправлять gRPC-запросы серверу.

В корне проекта autotests-api создадим файл grpc_client.py, который будет содержать реализацию клиента:

.
└── autotests-api/
    ├── grpc_client.py
    ├── grpc_server.py
    ├── user_service.proto
    ├── user_service_pb2.py
    └── user_service_pb2_grpc.py
Этот файл будет содержать код для установки соединения с сервером и отправки запросов.

Открываем grpc_client.py и добавляем следующий код:

import grpc

import user_service_pb2
import user_service_pb2_grpc

# Устанавливаем соединение с сервером
channel = grpc.insecure_channel('localhost:50051')
stub = user_service_pb2_grpc.UserServiceStub(channel)

# Отправляем запрос
response = stub.GetUser(user_service_pb2.GetUserRequest(username="Alice"))
print(response.message)  # Выведет: Привет, Alice!

---------------------------
1. Импорт необходимых модулей
---------------------------
    import grpc

    import user_service_pb2
    import user_service_pb2_grpc

Этот блок импортирует:

 - grpc — основная библиотека для работы с gRPC.
 - user_service_pb2 — автоматически сгенерированные классы сообщений из .proto-файла.
 - user_service_pb2_grpc — автоматически сгенерированные классы для сервиса, включая клиентский класс UserServiceStub, который нам нужен для отправки запросов.

---------------------------
2. Установка соединения с сервером
---------------------------
    # Устанавливаем соединение с сервером
    channel = grpc.insecure_channel('localhost:50051')
    stub = user_service_pb2_grpc.UserServiceStub(channel)

Этот код выполняет следующие действия:

1. Создает gRPC-канал

 - grpc.insecure_channel('localhost:50051') создает соединение с сервером, который работает на локальном хосте (localhost) и порту 50051.
 - insecure_channel означает незащищенное соединение без шифрования (TLS). Это удобно для локального тестирования.

2. Создает gRPC-клиента

 - UserServiceStub(channel) — это специальный клиентский объект, который используется для отправки запросов gRPC-серверу.
 - stub — это "заглушка" (stub), через которую клиент взаимодействует с сервером.

---------------------------
3. Отправка запроса
---------------------------
    # Отправляем запрос
    response = stub.GetUser(user_service_pb2.GetUserRequest(username="Alice"))
    print(response.message)  # Выведет: Привет, Alice!

Здесь клиент выполняет следующие шаги:

1. Создает gRPC-запрос

    - user_service_pb2.GetUserRequest(username="Alice") создает объект запроса, который содержит поле username="Alice".
    - Этот объект соответствует message GetUserRequest { string username = 1; } в user_service.proto.

2. Отправляет запрос серверу

    - stub.GetUser(...) вызывает метод GetUser на сервере через gRPC.
    - Клиент ожидает ответа, который будет объектом GetUserResponse.

3. Получает и выводит ответ

    - response.message содержит строку, полученную от сервера.
    - Если сервер работает, в консоли появится:
        Привет, Alice!

---------------------------
Итоговый процесс работы клиента
Клиент устанавливает соединение с gRPC-сервером (localhost:50051).
Создает gRPC-запрос с username="Alice".
Отправляет запрос серверу через stub.GetUser().
Сервер обрабатывает запрос и возвращает ответ "Привет, Alice!".
Клиент получает ответ и выводит его в консоль.
Теперь клиент можно запустить командой:

    python -m grpc_client

Вывод в консоли:
Привет, Alice!

Важно! Перед запуском клиента убедитесь, что gRPC-сервер запущен, иначе клиент не сможет установить соединение.

---------------------------
Итог
---------------------------
Генерация gRPC-кода и контрактов
 - Основу gRPC составляет .proto-файл, где мы описываем контракт API (сервис, методы, типы данных).
 - На основе .proto автоматически генерируются Python-классы для работы с запросами и ответами (*_pb2.py и *_pb2_grpc.py).
 - Это позволяет легко поддерживать строгую типизацию и избежать ошибок на клиенте и сервере.

Создание gRPC-сервера
 - Реализуется как Python-класс, унаследованный от сгенерированного UserServiceServicer.
 - Использует grpc.server(), чтобы обрабатывать входящие запросы.
 - Запускается на определенном порту (50051), ожидая подключения клиентов.

Создание gRPC-клиента
 - Клиент создает соединение через grpc.insecure_channel().
 - Вызывает методы сервиса через Stub, передавая параметры, определенные в .proto.
 - Получает ответ от сервера и работает с ним, как с обычным объектом.

gRPC автоматизирует создание клиент-серверного взаимодействия, генерируя код из контракта. Это снижает ошибки, улучшает производительность и делает API более надежным и предсказуемым.