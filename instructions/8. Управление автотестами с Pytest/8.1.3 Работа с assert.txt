Работа с assert
Ссылки:

Документация по работе с assert в Python
1. Что такое assert?
assert — это ключевое слово в Python, которое используется для проверки истинности условий. В pytest оно служит основным механизмом для валидации результатов тестов. Когда выражение, переданное в assert, возвращает False, срабатывает исключение AssertionError, что означает провал теста.

Пример использования assert:

assert 1 + 1 == 2
В этом примере assert проверяет, что сумма чисел 1 и 1 действительно равна 2

2. Как pytest работает с assert?
Pytest использует встроенный механизм для расширенной обработки assert выражений. В отличие от стандартного поведения Python, где при ошибке вы получаете просто сообщение об ошибке, pytest предоставляет детализированные отчеты и помогает глубже анализировать причину сбоя теста. Это одно из главных преимуществ pytest, упрощающее диагностику ошибок.

Пример:

def test_greeting():
    greeting = "Hello, world!"
    assert greeting == "Hi, world!"
В случае, если проверка не пройдет, pytest покажет подробный отчет:

E       AssertionError: assert 'Hello, world!' == 'Hi, world!'
E         - Hello, world!
E         + Hi, world!
pytest сравнит ожидаемое значение с фактическим и выделит, в чем именно заключается расхождение, что упрощает нахождение причины ошибки.

3. Основы работы assert в pytest
В pytest можно использовать assert для проверки множества разных условий. Это может быть сравнение чисел, строк, проверка работы логических операторов и любые другие условия, которые могут встречаться в тестах.

Основные типы проверок:

Равенство:

def test_equal():
    assert 1 == 1
Этот тест пройдет успешно, так как условие истинно.

Неравенство:

def test_not_equal():
    assert 1 != 2
Условие также будет истинным, и тест пройдет.

Проверка вхождения элемента:

def test_in_list():
    assert 3 in [1, 2, 3, 4]
Проверка булевого значения:

def test_boolean():
    is_authenticated = True
    assert is_authenticated
Если булевое значение True, тест пройдет. Если False — тест упадет.

Проверка исключений: pytest имеет встроенные средства для проверки того, что в коде выбрасывается нужное исключение. Например:

def test_zero_division():
    with pytest.raises(ZeroDivisionError):
        1 / 0
В этом примере при выполнении кода 1 / 0 (деление на ноль) будет вызвана ошибка ZeroDivisionError. Конструкция with pytest.raises проверяет, что данная ошибка действительно возникла. В результате, тест пройдет успешно (статус PASSED), поскольку ошибка является ожидаемым поведением

4. Дополнительные сообщения в assert
Иногда полезно добавить сообщение, которое будет отображаться, если проверка не прошла. Это сообщение поможет лучше понять, что именно произошло.

Пример с сообщением:

def test_sum():
    assert 1 + 1 == 3, "Сумма 1 и 1 должна быть 2!"
В случае ошибки, pytest выведет сообщение: "Сумма 1 и 1 должна быть 2!", что может облегчить диагностику проблемы.

5. Магия сравнения в pytest
Когда assert не проходит, pytest анализирует выражение и выводит дополнительную информацию. Например, если вы сравниваете объекты, pytest может показать различия между ними, что делает отчеты тестов более информативными.

Пример сложного сравнения:

def test_lists():
    assert [1, 2, 3] == [1, 2, 4]
pytest сгенерирует подробный отчет:

E       AssertionError: assert [1, 2, 3] == [1, 2, 4]
E         At index 2 diff: 3 != 4
Этот вывод точно укажет, на каком индексе произошло расхождение.

Работа с assert на практике
Рассмотрим на практическом примере, как работает assert. Для этого добавим в файл test_pytest.py два новых автотеста:

def test_first_try():  # Этот тест мы добавили в предыдущем шаге
    print("Hello World!")


def test_assert_positive_case():  # Новый тест, которые проверяет положительный кейс
    assert (2 + 2) == 4  # Ожидается, что тест пройдет


def test_assert_negative_case():  # Новый тест, которые проверяет негативный кейс
    assert (2 + 2) == 5  # Тут должна быть ошибка
И запустим автотесты командой:

python -m pytest -k "test_assert_" -s -v
Пример вывода в консоль при успешном запуске команды будет выглядеть так:

(.venv) username@ip-8-8-8-8 autotests-api % python -m pytest -k "test_assert_" -s -v
====================================================================== test session starts =======================================================================
platform darwin -- Python 3.11.9, pytest-8.3.3, pluggy-1.5.0 -- /Users/username/Documents/autotests-api/.venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/username/Documents/autotests-api
configfile: pytest.ini
collected 3 items / 1 deselected / 2 selected

tests/test_pytest.py::test_assert_positive_case PASSED
tests/test_pytest.py::test_assert_negative_case FAILED

============================================================================ FAILURES ============================================================================
___________________________________________________________________ test_assert_negative_case ____________________________________________________________________

    def test_assert_negative_case():  # Новый тест, которые проверяет негативный кейс
>       assert (2 + 2) == 5  # Тут должна быть ошибка
E       assert (2 + 2) == 5

tests/test_pytest.py:10: AssertionError
==================================================================== short test summary info =====================================================================
FAILED tests/test_pytest.py::test_assert_negative_case - assert (2 + 2) == 5
=========================================================== 1 failed, 1 passed, 1 deselected in 0.06s ============================================================
1. Фильтр по именам тестов:

Команда pytest -k "test_assert_" -s -v запускает тесты, имена которых содержат подстроку "test_assert_". Это означает, что тест test_first_try был проигнорирован, а test_assert_positive_case и test_assert_negative_case выбраны для выполнения.

2. Вывод о результатах тестов:
Тест test_assert_positive_case прошел успешно (PASSED), так как условие assert (2 + 2) == 4 истинно.
Тест test_assert_negative_case провалился (FAILED), потому что условие assert (2 + 2) == 5 ложно.
3. Подробное объяснение работы assert:
Когда вы используете assert, вы говорите тесту проверить, что некое условие верно. Если оно истинно, тест пройдет. Если оно ложно, произойдет исключение AssertionError, и тест будет отмечен как провалившийся.

4. Лог провалившегося теста:
tests/test_pytest.py::test_assert_negative_case FAILED
Pytest показал, что тест test_assert_negative_case провалился.

    def test_assert_negative_case():
>       assert (2 + 2) == 5 # Тут должна быть ошибка
E       assert (2 + 2) == 5
Pytest выводит строку, где произошла ошибка: assert 2 + 2 == 5. Это означает, что выражение слева (2 + 2) не равно значению справа (5), поэтому возникает AssertionError. Pytest автоматически выводит как само условие, так и фактические значения, что упрощает диагностику.

Важно! Существует распространенное заблуждение, что каждый API автотест должен содержать только одну проверку. Многие неправильно трактуют это утверждение, поэтому давайте разберем, как его понимают большинство, и как его следует понимать на самом деле.

Как это понимают большинство:

Многие считают, что в API автотесте должна быть только одна проверка, что означает наличие только одного assert. Например, в тестах REST API такие люди проверяют только статус-код ответа, игнорируя содержимое тела ответа, заголовки или другие важные параметры. В итоге, выражение "каждый автотест должен содержать только одну проверку" воспринимается слишком буквально, что может сильно ограничить тестирование реального сценария.

Как это должно пониматься на самом деле:

Правильная интерпретация заключается в том, что каждый API автотест должен проверять единый сценарий бизнес-логики. Другими словами, тест должен быть сфокусирован на конкретной бизнес-функции или потоке, который он тестирует.

Например, если у нас есть банковский сервис, и наша задача — протестировать только операцию пополнения счета через API, то автотест должен проверять только этот процесс. Он не должен проверять баланс других счетов или информацию о владельце. Весь фокус теста должен быть направлен на успешное (или неуспешное) выполнение запроса на пополнение счета и на все связанные с этим параметры.

Множественные проверки в контексте одного сценария

При этом, API автотест может (и должен) содержать несколько проверок, если они относятся к одному сценарию. Например, в тестах API хорошей практикой считается проверка нескольких ключевых параметров после каждого запроса:

Отправили запрос на пополнение счета — проверили, что статус-код 200 (или другой ожидаемый код ошибки).
Проверили тело ответа — убедились, что баланс изменился на ожидаемую сумму.
Проверили заголовки ответа — убедились, что пришли корректные значения Content-Type и других критически важных заголовков.
Проверили данные в БД (если тест выполняется с доступом к базе) — убедились, что изменения корректно сохранены.
Таким образом, API автотест может и должен содержать несколько assert-ов, если они проверяют правильность выполнения последовательных шагов одного сценария. Это является хорошей практикой, так как каждый шаг может повлиять на успешность сценария в целом.

Резюме:

Правильное понимание выражения "каждый автотест должен содержать одну проверку" состоит в том, что API автотест должен проверять один сценарий или одну бизнес-логику, а не ограничиваться одним assert-ом. При этом тест должен быть достаточно подробным, чтобы на каждом этапе убедиться, что сценарий работает правильно.