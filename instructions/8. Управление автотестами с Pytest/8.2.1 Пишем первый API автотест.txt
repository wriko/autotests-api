
В этом уроке мы напишем первый API автотест. К этому моменту мы уже освоили работу с API и HTTP-протоколом, а также имеем базовое понимание написания автотестов.

Обращаю внимание, что пока мы не изучили всю мощь pytest, но уже знаем, как писать простые автотесты. Этого достаточно, чтобы приступить к практике.

========================
Цель урока
========================
Наша задача — написать автотест для эндпоинта POST /api/v1/users, который отвечает за создание пользователя. При этом мы будем применять лучшие практики, которые изучили ранее:

1. Использование API-клиентов для отправки запросов.
2. Работа с Pydantic-моделями для валидации данных.
3. Структурирование кода и тестов по принципам читаемости и поддержки.

========================
1. Создаем файл test_users.py
========================
Для начала создадим новый файл test_users.py в папке tests. В этом файле мы будем хранить автотесты, связанные с API пользователей /api/v1/users:

.
└── autotests-api/
    └── tests/
        └── test_users.py
В дальнейшем будем расширять этот файл, добавляя новые тест-кейсы для различных операций с пользователями (создание, получение, обновление, удаление).

========================
2. Создаем автотест test_create_user
========================
Теперь создадим базовый автотест, который проверяет создание пользователя.

Как назвать тест правильно?
Название автотеста должно четко отражать его суть. Избегайте абстрактных или неинформативных имен, таких как:
 - test_user (слишком общее)
 - test_get (непонятно, что именно тестируется)
 - test_api (не отражает логику теста)

Лучше сразу указывать конкретное действие:
 - test_create_user – проверка создания пользователя
 - test_get_user_by_id – проверка получения пользователя по ID
 - test_delete_user – проверка удаления пользователя

Название должно быть таким, чтобы, прочитав его, сразу было понятно, что тест проверяет.
---------------------------------
Добавляем код в test_users.py
---------------------------------
Откроем файл test_users.py и добавим следующий код:

    from http import HTTPStatus

    from clients.users.public_users_client import get_public_users_client
    from clients.users.users_schema import CreateUserRequestSchema


    def test_create_user():
        # Инициализируем API-клиент для работы с пользователями
        public_users_client = get_public_users_client()

        # Формируем тело запроса на создание пользователя
        request = CreateUserRequestSchema()
        # Отправляем запрос на создание пользователя
        response = public_users_client.create_user_api(request)

        # Проверяем статус-код ответа
        assert response.status_code == HTTPStatus.OK, 'Некорректный статус-код ответа'

Рассмотрим код автотеста test_create_user детально:

1. Описываем тестовую функцию
    def test_create_user():

2. Получаем экземпляр API-клиента для работы с API /api/v1/users.
Этот клиент инкапсулирует логику отправки запросов, скрывая детали HTTP-запросов.
    public_users_client = get_public_users_client()

3. Создаем объект запроса, используя Pydantic-схему CreateUserRequestSchema
    request = CreateUserRequestSchema()

4. Вызываем метод API-клиента для отправки POST-запроса. Передаем в него ранее созданный объект request. Результат сохраняем в переменную response, содержащую HTTP-ответ.
    response = public_users_client.create_user_api(request)

5. Проверяем, что сервер вернул 200 OK. Если статус не 200, тест упадет с ошибкой "Некорректный статус-код ответа".
    assert response.status_code == HTTPStatus.OK, "Некорректный статус-код ответа"


Магические числа в тестах – почему это плохо?
Рассмотрим два варианта кода:

Плохой вариант:
    assert response.status_code == 200
Что не так?
Число 200 не объясняет само по себе, что оно означает.


Хороший вариант:
    assert response.status_code == HTTPStatus.OK
Преимущества:
Читаемость – сразу понятно, что проверяется успешный ответ.

------------------------------------------
3. Расширяем проверки автотеста test_create_user
------------------------------------------
Сейчас наш автотест test_create_user выполняет только одну базовую проверку — статус кода ответа, этого явно недостаточно. Нам также хотелось бы проверить тело ответа и убедиться, что пользователь действительно был создан в системе. Добавим дополнительные проверки, чтобы удостовериться, что данные в ответе совпадают с данными в запросе на создание пользователя.

    from http import HTTPStatus

    from clients.users.public_users_client import get_public_users_client
    from clients.users.users_schema import CreateUserRequestSchema, CreateUserResponseSchema


    def test_create_user():
        # Инициализируем API-клиент для работы с пользователями
        public_users_client = get_public_users_client()

        # Формируем тело запроса на создание пользователя
        request = CreateUserRequestSchema()
        # Отправляем запрос на создание пользователя
        response = public_users_client.create_user_api(request)
        # Инициализируем модель ответа на основе полученного JSON в ответе
        # Также благодаря встроенной валидации в Pydantic дополнительно убеждаемся, что ответ корректный
        response_data = CreateUserResponseSchema.model_validate_json(response.text)

        # Проверяем статус-код ответа
        assert response.status_code == HTTPStatus.OK, 'Некорректный статус-код ответа'

        # Проверяем, что данные ответа совпадают с данными запроса
        assert response_data.user.email == request.email, 'Некорректный email пользователя'
        assert response_data.user.last_name == request.last_name, 'Некорректный last_name пользователя'
        assert response_data.user.first_name == request.first_name, 'Некорректный first_name пользователя'
        assert response_data.user.middle_name == request.middle_name, 'Некорректный middle_name пользователя'

Подробное объяснение кода:

1. Обработка ответа: Получив ответ от API, мы используем CreateUserResponseSchema.model_validate_json() для валидации данных ответа. Это важный момент, так как Pydantic автоматически проверяет, что структура и типы данных в ответе соответствуют ожидаемым. Это помогает убедиться, что API вернуло корректный ответ.

2. Проверка статус-кода: Мы проверяем, что статус-код ответа равен HTTPStatus.OK, что подтверждает успешную обработку запроса.

3. Проверка данных в ответе: Далее мы убеждаемся, что данные пользователя, возвращенные в ответе, совпадают с данными, переданными в запросе. Мы проверяем email, first_name, last_name, и middle_name для того, чтобы удостовериться, что данные действительно были правильно сохранены.

Важные замечания по проверкам в API автотестах:
Проверка — это ключевая часть любого автотеста, и она выполняется для того, чтобы удостовериться, что система работает корректно. В автотесте test_create_user все выглядит хорошо на первый взгляд, но есть важные нюансы. Мы создали пользователя, и, казалось бы, все прошло успешно. Но есть ли гарантия, что пользователь действительно был создан?

В реальных, более сложных системах, таких как распределенные системы с микросервисами, запрос на создание пользователя может быть успешным, но на самом деле создание пользователя в системе не гарантировано. Ответ может быть успешным, и пользовательские данные могут быть возвращены в ответе, но на самом деле система может не завершить процесс создания пользователя, например, из-за сложных внутренних процессов, таких как асинхронная обработка данных, взаимодействие с другими сервисами или очередями сообщений.

Чтобы уменьшить этот риск, мы можем добавить дополнительный запрос для получения данных о пользователе после его создания. Это позволит нам убедиться, что пользователь действительно был создан и что его данные доступны в системе.

В случае сложных систем, например банковских приложений, важно всегда уточнять, как именно работает бизнес-логика системы и как гарантируется создание данных. Для таких случаев можно создавать отдельные тесты, как, например, test_get_user, который будет проверять, что пользователь существует в системе после его создания.

Таким образом, в реальных проектах стоит учитывать, что успешный ответ на запрос не всегда является гарантией того, что операция была завершена успешно в полной мере.

4. Запуск автотеста
Теперь давайте финально запустим автотест создания пользователя и убедимся, что он работает ожидаемо, то есть проходит успешно. Для этого выполним следующую команду:

python -m pytest -k "test_create_user" -s -v
Здесь:

-m pytest — запуск тестов с помощью pytest.
-k "test_create_user" — фильтрация тестов, чтобы запустить только test_create_user.
-s — позволяет выводить в консоль print() и stdout (если есть в тестах).
-v — включает подробный вывод (verbose).
При успешном выполнении команды в консоли будет следующий вывод:

(.venv) username@ip-192-168-8-7 autotests-api % python -m pytest -k "test_create_user" -s -v
====================================================================== test session starts =======================================================================
platform darwin -- Python 3.11.9, pytest-8.3.5, pluggy-1.5.0 -- /Users/username/Documents/autotests-api/.venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/username/Documents/autotests-api
configfile: pytest.ini
plugins: Faker-36.2.2, anyio-4.8.0
collected 4 items / 3 deselected / 1 selected

tests/test_users.py::test_create_user PASSED

================================================================ 1 passed, 3 deselected in 0.44s =================================================================
Разбор вывода

collected 4 items / 3 deselected / 1 selected

Всего в проекте нашлось 4 теста.
3 теста были пропущены (deselected), потому что мы указали фильтр -k "test_create_user".
1 тест (test_create_user) был выполнен.
tests/test_users.py::test_create_user PASSED

Указывает, что тест test_create_user прошел успешно.
1 passed, 3 deselected in 0.44s

Подтверждает, что один тест прошел (passed), три были исключены (deselected).
Время выполнения теста составило 0.44 секунды.
Лог выше говорит нам о том, что API автотест успешно прошел! Поздравляю вас с первым API автотестом