Фикстуры в pytest


Официальная документация Pytest по работе с фикстурами - https://docs.pytest.org/en/6.2.x/fixture.html

Фикстуры в pytest — это мощный механизм, который помогает настроить и упростить тестирование. Они позволяют повторно использовать код настройки и завершения (setup и teardown) в тестах, что особенно полезно при тестировании сложных систем.

Фикстуры помогают:
 - Инициализировать окружение.
 - Подготавливать тестовые данные.
 - Устанавливать соединения с базами данных.
 - Изолировать тесты от изменений в глобальном состоянии.

Фикстуры обладают следующими свойствами:
 - Повторное использование: можно определить фикстуру один раз и использовать её в разных тестах.
 - Изоляция тестов: фикстуры изолируют состояние тестов, избегая побочных эффектов между ними.
 - Гибкость: фикстуры могут быть настроены для работы с разными уровнями выполнения (например, на уровне теста, модуля или сессии).

------------------------------
Определение фикстуры
------------------------------
Фикстуры в pytest создаются с использованием декоратора @pytest.fixture. Они могут быть переданы в качестве аргументов в тестовые функции, и pytest автоматически выполнит фикстуру перед запуском теста.

import pytest

    # Определение фикстуры
    @pytest.fixture
    def sample_fixture():
        return {"key": "value"}

    # Использование фикстуры в тесте
    def test_using_fixture(sample_fixture):
        assert sample_fixture["key"] == "value"

Если разобраться по факту, то фикстура это просто функция, которая помечена декоратором @pytest.fixture. Далее название фикстуры, а в данном случае sample_fixture, передается в автотест в качестве аргумента def test_using_fixture(sample_fixture)

------------------------------
Сценарии использования
------------------------------
Подготовка данных
Фикстуры часто используются для подготовки данных для тестов. Например, фикстура может вернуть тестовые данные, которые используются в нескольких тестах.

Пример:

    @pytest.fixture
    def user_data():
        return {"username": "test_user", "email": "test@example.com"}

    def test_user_email(user_data):
        assert user_data["email"] == "test@example.com"

    def test_user_username(user_data):
        assert user_data["username"] == "test_user"


Инициализация ресурсов
Фикстуры также могут использоваться для инициализации ресурсов, таких как соединение с базой данных, открытие файлов, открытие браузера, инициализация API клиента и т.д.

Пример:

    @pytest.fixture
    def users_client():
        client = new_users_client() # Создаем новый API клиент (setup)
        yield client
        client.close()  # Закрываем сетевое соединение (teardown)

    def test_create_user(users_client): # Внутри автотеста уже работает с готовым объектом API клиента
        users_client.create_user()


Фоновые действия

Фикстуры могут использоваться для выполнения каких-либо фоновых действий, например, после каждого автотеста нам необходимо отправлять данные в сервис аналитики. Для этого необходимо использовать фикстуру с аргументом autouse=True.

Пример:

    import pytest


    @pytest.fixture(autouse=True)
    def send_analytics_data():
        print("Данная фикстура будет запущена автоматически перед каждым автотестом")


    def test_1():  # При этом такую фикстуру не нужно передавать в тест
        pass


    def test_2():
        pass


    def test_3():
        pass

Важно! В примере выше фикстура send_analytics_data будет выполнена автоматически перед каждым автотестом. Нужно быть осторожным при использовании аргумента autouse=True, это может вызвать неявные изменения, которые в большом проекте очень сложно будет отследить

------------------------------
Уровни фикстур
------------------------------
Фикстуры можно применять на разных уровнях:

 - scope="function" (по умолчанию): выполняется перед каждым тестом. Обычно используется для таких действий, как открытие браузера, создание какой-либо сущности, создание/удаление данных до/после автотеста. Самый часто используемый scope
 - scope="module": выполняется один раз на уровне модуля. Определение module в python. Очень редко используется
 - scope="class": выполняется один раз для каждого класса с тестами. Используется для таких действий, как создание данных, которые нужны для всего тестового класса
 - scope="session": выполняется один раз за всю сессию тестирования. Используется для данных, которые нужны для всей тестовой сессии, например настройки автотестов

    @pytest.fixture(scope="function")
    def function_users_client():
        print("Данная фикстура будет запущена на каждый автотест")

    @pytest.fixture(scope="class")
    def class_users_client():
        print("Данная фикстура будет запущена на каждый тестовый класс")

    @pytest.fixture(scope="module")
    def module_users_client():
        print("Данная фикстура будет запущена на каждый модуль python")

    @pytest.fixture(scope="session")
    def session_users_client():
        print("Данная фикстура будет запущена один раз на всю тестовую сессию")

------------------------------
Использование yield для teardown
------------------------------
Фикстуры могут выполнять не только setup (подготовку ресурсов), но и teardown (очистку ресурсов) с помощью ключевого слова yield. Все, что идет после yield, выполняется после завершения теста.

    @pytest.fixture
    def setup_and_teardown():
        # Подготовка — данный код будет выполнен до начала автотеста
        resource = "some resource"
        yield resource # Выполняется автотест
        # Очистка — данный код будет выполнен полсе завершения автотеста
        print("Teardown: освобождение ресурса")

Важно! Код до ключевого слова yield, выполняется до начала автотеста, код который находится после ключевого слова yield, выполняется после завершения автотеста. При этом фикстура будет выполняться не зависимо от того, был тест успешным или провалился

 Разбор Setup и Teardown в контексте фикстур в pytest
Setup и Teardown — это два важных этапа в процессе тестирования, которые отвечают за подготовку и завершение работы каждого теста.

Setup — это код, который выполняется перед тестом. Он нужен для подготовки необходимых ресурсов, таких как создание тестовых данных, настройка окружения, подключение к базе данных и т.д.
Teardown — это код, который выполняется после теста. Его задача — очистить за собой всё, что было создано в процессе теста, например, закрыть соединения с базами данных, удалить временные файлы или вернуть состояние системы в исходное.
В pytest это реализуется через фикстуры, которые обеспечивают настройку и очистку состояния тестов. Вместо того чтобы повторять код setup и teardown в каждом тесте, фикстуры позволяют инкапсулировать эту логику и использовать её повторно в разных тестах.

    import pytest

    @pytest.fixture
    def setup_teardown():
        # Это часть Setup — код, который выполняется перед тестом
        print("Setup: Инициализация данных или окружения")
        test_data = {"user": "testuser", "password": "testpass"}

        # Это часть Teardown — код, который выполняется после теста
        yield test_data  # Здесь возвращаем данные для теста

        print("Teardown: Очистка данных или окружения")
        # Здесь можно закрыть соединения, удалить временные файлы и т.д.
        # Например, удалить созданные записи в базе данных, если таковые были.

    def test_login(setup_teardown):
        # Здесь setup_teardown будет содержать возвращённые данные из фикстуры
        assert setup_teardown["user"] == "testuser"
        assert setup_teardown["password"] == "testpass"

Что происходит в примере:
1. Setup: Сначала выполняется код до yield, который инициализирует необходимые данные для теста. В данном случае это словарь с именем пользователя и паролем.
2. Тест: После этого pytest выполняет сам тест, передавая данные из фикстуры в тестовую функцию.
3. Teardown: После выполнения теста выполняется код после yield, который очищает или завершает все необходимые процессы, такие как закрытие соединений или удаление временных файлов.

Почему использовать фикстуры с setup и teardown?
1. Повторное использование: Код для настройки и очистки можно писать один раз в фикстуре и использовать его в разных тестах.
2. Чистота кода: Фикстуры делают код тестов чище и легче для восприятия, так как избавляют от повторений.
3. ибкость: Вы можете настраивать фикстуры на разные уровни: на уровне теста, модуля или даже сессии. Например, если вам нужно подготовить базу данных для всех тестов в модуле, вы можете использовать фикстуру на уровне модуля.


--------------------
Фикстуры с зависимостями
--------------------
Фикстуры могут зависеть от других фикстур, что упрощает создание сложных цепочек зависимостей между ресурсами.

    @pytest.fixture
    def settings(): # Инициализируем фикстуру с настройками
        return new_settings()

    @pytest.fixture
    def users_client(settings): # Передаем фикстуру settings
        return new_users_client(settings.host)

    def test_create_user(users_client):
        users_client.create_user()

Важно! Делаем вывод, что фикстуры могут использоваться не только внутри автотестов, но и внутри других фикстур, как в примере выше